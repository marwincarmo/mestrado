<!DOCTYPE html>
<html lang="" xml:lang="">
  <head>
    <title>Cross-cultural adaptation and psychometric studies of the Dysfunctional Beliefs and Attitudes about Sleep scale and the Sleep Problem Acceptance Questionnaire</title>
    <meta charset="utf-8" />
    <meta name="author" content="Marwin M I B Carmo" />
    <script src="quals_slides_files/header-attrs/header-attrs.js"></script>
    <script src="quals_slides_files/xaringanExtra-progressBar/progress-bar.js"></script>
    <link rel="stylesheet" href="xaringan-themer.css" type="text/css" />
    <link rel="stylesheet" href="css/custom.css" type="text/css" />
  </head>
  <body>
    <textarea id="source">
class: center, middle, inverse, title-slide

.title[
# Cross-cultural adaptation and psychometric studies of the Dysfunctional Beliefs and Attitudes about Sleep scale and the Sleep Problem Acceptance Questionnaire
]
.subtitle[
## Exame de qualificação
]
.author[
### Marwin M I B Carmo
]
.institute[
### Instituto de Psiquiatria, Faculdade de Medicina da Universidade de São Paulo
]
.date[
### <img src ='img/fapesp-ipq.png' width = '30%'>
]

---







<div>
<style type="text/css">.xaringan-extra-logo {
width: 365px;
height: 79px;
z-index: 0;
background-image: url(img/fapesp-ipq.png);
background-size: contain;
background-repeat: no-repeat;
position: absolute;
right:1em;bottom:1em;
}
</style>
<script>(function () {
  let tries = 0
  function addLogo () {
    if (typeof slideshow === 'undefined') {
      tries += 1
      if (tries < 10) {
        setTimeout(addLogo, 100)
      }
    } else {
      document.querySelectorAll('.remark-slide-content:not(.my-title):not(.inverse):not(.hide_logo)')
        .forEach(function (slide) {
          const logo = document.createElement('div')
          logo.classList = 'xaringan-extra-logo'
          logo.href = null
          slide.appendChild(logo)
        })
    }
  }
  document.addEventListener('DOMContentLoaded', addLogo)
})()</script>
</div><style>.xe__progress-bar__container {
  top:0;
  opacity: 1;
  position:absolute;
  right:0;
  left: 0;
}
.xe__progress-bar {
  height: 10px;
  background-color: #c31919;
  width: calc(var(--slide-current) / var(--slide-total) * 100%);
}
.remark-visible .xe__progress-bar {
  animation: xe__progress-bar__wipe 200ms forwards;
  animation-timing-function: cubic-bezier(.86,0,.07,1);
}
@keyframes xe__progress-bar__wipe {
  0% { width: calc(var(--slide-previous) / var(--slide-total) * 100%); }
  100% { width: calc(var(--slide-current) / var(--slide-total) * 100%); }
}</style>


# Introdução

Diversos modelos cognitivos da insônia destacam a excitação cognitiva como um dos principais mantenedores do transtorno.

A Terapia Cognitivo-comportamental para a insônia (TCC-I) é um tratamento não farmacológico de eficácia comprovada. Outra alternativa terapêutica com evidências favoráveis recentes é a Terapia de Aceitação e Compromisso (ACT).

Duas ferramentas desenvolvidas para avaliar as cognições relacionadas ao sono são a **Dysfunctional Beliefs and Attitudes about Sleep Scale (DBAS)** e o **Sleep Problem Acceptance Questionnaire (SPAQ)**.

Dado que estas medidas foram desenvolvidas em um contexto cultural diferente, é necessário investigar se apresentam boas evidências de validade quando utilizadas com uma amostra brasileira.

---
# Crenças e atitudes disfuncionais sobre o sono

As crenças disfuncionais sobre o sono podem exacerbar a atividade cognitiva negativa. Em excesso, provocam excitação e angústia. Estes sentimentos podem gerar percepções distorcidas sobre o sono e superestimação das consequências da falta de sono (Harvey, 2002).

Diversos estudos identificaram que as crenças e atitudes disfuncionais sobre o sono são mediadoras da perpetuação da insônia (Akram et al., 2020; Chow et al., 2018; Harvey et al., 2017; Lancee et al., 2019)

O modelo Microanalítico de Morin (1993) sugere que insônia é mantida por um processo cíclico de excitação, pensamentos disfuncionais, hábitos desadaptativos, e consequências.

---
# Crenças e atitudes disfuncionais sobre o sono
## Relações

Indivíduos com sintomas graves de insônia tendem a endossar mais fortemente as crenças disfuncionais sobre o sono.

A gravidade da insônia, por sua vez, está associada à ansiedade e depressão.

Atribuições e expectativas irreais sobre o sono originam pensamentos geradores de ansiedade.

Além disto, individuos com altos níves de crenças disfuncionais estão mais vulneráveis à depressão em função do estilo de pensamento negativo.

---
# Crenças e atitudes disfuncionais sobre o sono
## Mensuração

Dysfunctional Beliefs and Attitudes About Sleep Scale (DBAS).

Originalmente desenvolvida em 30 itens, foi reduzida para uma versão de 16 itens que é a mais utilizada em pesquisas atuais e apresenta boas propriedades psicométricas.

Os itens são respondidos em uma escala Likert de 11 pontos, de 0 (discordo fortemente) a 10 (concordo fortemente).

Apresenta uma estrutura de 4 fatores: (a) Consequências da insônia, (b) Preocupação com o sono. (c) Expectativas sobre o sono, e (d) Medicação.


---
# Aceitação dos problemas de sono

Terapias comportamentais de terceira geração incluíram a metacognição como componente do tratamento.

Nesta perspectiva, a insônia é mantida por processos de interferência no sono e processos de interpretação do sono que se retro-alimentam.

Esforços de controle metacognitivo previnem os processos espontâneos de relaxamento.

O foco não é na eliminação das crenças disfuncionais e pensamentos negativos. A aceitação pode auxiliar na forma como o conteúdo disfuncional é interpretado, diminuindo sua interferência no sono.

---
# Aceitação dos problemas de sono
## Relações


A insônia está ligada a um forte apego às necessidades e expectativas do sono, o que alimenta a preocupação, a supressão de pensamentos e a ruminação.

A rigidez de pensamento ocasionada por inflexibilidade psicológica está associada a sintomas de depressão e ansiedade.

Espera-se que a aceitação tenha uma relação com a insônia, ansiedade e depressão semelhante ao modelo cognitivo comportamental.

---
# Aceitação dos problemas de sono
## Mensuração

O Sleep Problem Acceptance Questionnaire (SPAQ) é a única medida de aceitação dos problemas do sono publicada com eviências de validade

Examina o papel da aceitação em relação a qualidade do sono.

Possui oito itens, respondidos em uma escala de 7 pontos, de 0 (discordo) a 6 (concordo completamente).

Sua estrutura é composta por dois fatores: Engajamento em atividades e Disposição.


---
# O processo de adaptação transcultural
.v-center[


Antes de usar um instrumento psicológico existente em um contexto distinto de como foi originalmente desenvolvido, é fundamental avaliar a existência e a similaridade do construto, pois ele pode se manifestar de forma diferente.

Cinco tipos de equivalência:

1. Eqivalência conceitual;  
2. Equivalência de itens;  
3. Equivalência semântica;  
4. Equivalência operacional;  
5. Equivalência de medida.
]
---
# O processo de adaptação transcultural
## 1. Tradução dos itens

No mínimo dois tradutores independentes fluentes tanto no idioma original do instrumento quanto no idioma alvo.

Idealmente um com conhecimento do construto avaliado pela escala e outro sem familiaridade com este contexto.

Os tradutores trabalham de forma independente entre si.
---
# O processo de adaptação transcultural
## 2. Síntese das traduções

Com as traduções prontas, um comitê deve se reunir para considerar as traduções e o instrumento original de modo a produzir uma versão única.

O comitê pode ser formado pelos próprios tradutores e um terceiro juíz, ou especialistas no conceitos avaliados pela escala.

---
# O processo de adaptação transcultural
## 3. Retro-tradução

Nesta fase os autores do instrumento original são convidados a avaliar a equivalência entre a versão original e a traduzida.

A versão sintetizada é traduzida para o idioma original por, no mínimo, dois novos tradutores nativos. A mesma formação do comitê da etapa anterior pode se reunir novamente para produzir uma versão síntese da retro-tradução.

---
# O processo de adaptação transcultural
## 4. Comitê de especialistas

O grupo pode ser composto por metodologistas, profissionais da saúde, profissionais de idiomas e tradutores (retrodutores e tradutores) até agora envolvidos no processo.

Este comitê participa das etapas onde é necessário tomar decisões em relação a estrutura, layout, instruções, e a abrangência e adequação das expressões contidas nos itens.

---
# O processo de adaptação transcultural
## 5. Estudo piloto

Esta etapa pode revelar problemas não antevistos que os respondentes podem encontrar ou dificuldade de compreensão dos itens ou das instruções do teste. Os participantes também podem sugerir alterações de termos e expressões.

É uma etapa importante para avaliar se os participantes compreendem o conceito das perguntas de forma consistente e conforme pretendido pelos pesquisadores.

O pré-teste pode ser conduzido com grupos focais ou por entrevistas cognitivas individuais.

É importante que a amostra represente a diversidade que se espera encontrar no uso cotidiano do instrumento.

---
# Objetivos

a. Desenvolver uma versão em Português do Brasil das escalas Dysfunctional Beliefs and Attitudes about Sleep Scale (DBAS-16) e Sleep
Problem Acceptance Questionnaire (SPAQ);

b. Examinar sua estrutura fatorial;

c. Examinar a validade de construto.

---
# Método
## Participantes e delineamento

O tamanho amostral adequado calculado pelo teste de *close fit* de RMSEA &lt; 0.05 com poder de 0.80 and `\(\alpha\)` de 0.05 foi de 920 participantes.

Os critérios de inclusão foram: idade entre 18 e 59 anos e habilidade de ler e escrever em Português.

Os participantes foram recrutados por anúncios em redes sociais e divulgação entre médicos e psicólogos.

Os dados foram coletados entre Maio de 2021 e Julho de 2022, de forma *online* com auxílio do *software* REDCap. Foram incluídos participantes com e sem problemas de sono.
---
# Método
## Tradução dos itens

Os itens e instrução do teste foram traduzidos do inglês para o português por três tradutores independentes. Dois eram profissionais do sono e o terceiro, professor de inglês.

Um comitê de especialistas formado por profissionais especializados em insônia sintetizou as três traduções em uma única versão.

Dois tradutores nativos em inglês realizaram as retro-traduções, que foram novamente sintetizadas pelo mesmo comitê. A versão retro-traduzida foi enviada para apreciação dos autores do instrumento.

Após incorporar as sugestões dos autores, o instrumento foi submetido a um estudo piloto no formato de entrevistas cognitivas com 15 participantes: 12 mulheres e média de idade de 43 anos.
---
&lt;img src="../diag_ptbr.png" width="40%" style="display: block; margin: auto;" /&gt;
---
# Método
## Instrumentos auxiliares

1. Índice de Gravidade da Insônia (IGI);

2. Escala Hospitalar de Ansiedade e Depressão (EHAD);

3. Acceptance and Action Questionnaire-II (AAQ-II).

---
# Método
## Plano de análise
### Estatísticas descritivas

Avaliação da variação dos itens, sua distribuição e erros de entrada.

Correlação inter-item.

Avaliação da presença de outliers multivariados pela distância de Mahalanobis para identificar padrões de resposta fora do comum.
---
# Método
## Plano de análise
### Teoria de resposta ao item Não-paramétrica (NIRT)

Mokken Scaling Analysis (MSA): possui pressupostos mais flexíveis e trata os dados como ordinais.

Investiga:

a. Unidimensionalidade;  
b. *Item step response function*: probabilidade de obter determinado escore dado o nível de traço latente;  
c. Monotonicidade;  
d. Funcionamento diferencial do item.

---
# Método
## Plano de análise
### Evidências de validade estrutural

Análise Fatorial Confirmatória (AFC) replicando o modelo original.

O ajuste do modelo será avaliado por meio dos índices: qui-quadrado `\((\chi^2)\)`; Tucker-Lewis Index (TLI); Comparative Fit Index (CFI);  Relative Noncentrality Index (RNI); Root Mean Square Error of Approximation (RMSEA); and Standardized Root Mean Squared Residual (SRMR).

Pontos de corte: SRMR `\(\le\)` .08, RMSEA `\(\le\)` .06, and CFI, TLI, and RNI `\(\ge\)` .96.

Análise Fatorial Multi-grupo (ACFMG) para investigar invariância de medida.

---
# Método
## Plano de análise
### Confiabilidade

Alfa de Cronbach `\((\alpha)\)`, Ômega total de McDonald `\((\omega_t)\)`, e Ômega hierárquico `\((\omega_h)\)`.

Índices `\(\ge\)` .70 são considerados aceitáveis.

Avaliação da consistência interna por meio de teste-reteste (14 dias): correlações fortes indicam alta confiabilidade temporal.
---
# Método
## Plano de análise
### Validade concorrente

Espera-se uma correlação positiva entre os escores da DBAS-16 com o EHAD (depressão e ansiedade) e com o IGI.

As mesmas correlações são esperadas para o SPAQ, com o acréscimo de correlação negativa com o AAQ-II.
---
# Método
## Plano de análise
### Psicometria de redes

Transtornos mentais são interpretados como uma rede causal de interações entre sintomas ao invés de uma causa única comum.

A dimensionalidade das escalas será avalida de forma exploratória por meio da *Exploratory Graph Analysis* (EGA). Este método identifica o número de comunidades e seu conteúdo dentro da rede.

Comparado a métodos tradicionais (e.g., Análise Paralela, Scree plot, etc.) a EGA apresentou maior acurácia para estimar corretamente o número de fatores, e menor erro de viés médio, em estudos de simulação.
---
# Resultados parciais

Os participantes do estudo piloto relatarm bom entendimento dos itens e instrução dos testes.

O termo "desequilíbrio químico" do item 13 da DBAS-16 foi alterado para "desequilíbrio do meu organismo".

Foi necessário adicionar uma instrução específica na SPAQ para os participantes sem problemas de sono, pedindo para que respondessem imaginando uma situação em que tiveram dificuldades para dormir.
---
# Resultados parciais

A amostra final foi composta por 1397 participantes, dos quais 1130 eram mulheres e 1062 relataram sintomas de insônia.

A média de idade da amostra foi de 38.41 anos (dp = 9.79).

619 participantes tinham emprego formal e 1085 diploma universitário.
---
# Próximas etapas

- Nov/22 - Jan/23: Análise dos dados

- Fev/23 - Mai/23: Escrita dos artigos

- Jun/23: Defesa da tese



    </textarea>
<style data-target="print-only">@media screen {.remark-slide-container{display:block;}.remark-slide-scaler{box-shadow:none;}}</style>
<script src="https://remarkjs.com/downloads/remark-latest.min.js"></script>
<script>var slideshow = remark.create({
"slideNumberFormat": "%current%",
"highlightStyle": "github",
"highlightLines": true,
"ratio": "16:9",
"countIncrementalSlides": true
});
if (window.HTMLWidgets) slideshow.on('afterShowSlide', function (slide) {
  window.dispatchEvent(new Event('resize'));
});
(function(d) {
  var s = d.createElement("style"), r = d.querySelector(".remark-slide-scaler");
  if (!r) return;
  s.type = "text/css"; s.innerHTML = "@page {size: " + r.style.width + " " + r.style.height +"; }";
  d.head.appendChild(s);
})(document);

(function(d) {
  var el = d.getElementsByClassName("remark-slides-area");
  if (!el) return;
  var slide, slides = slideshow.getSlides(), els = el[0].children;
  for (var i = 1; i < slides.length; i++) {
    slide = slides[i];
    if (slide.properties.continued === "true" || slide.properties.count === "false") {
      els[i - 1].className += ' has-continuation';
    }
  }
  var s = d.createElement("style");
  s.type = "text/css"; s.innerHTML = "@media print { .has-continuation { display: none; } }";
  d.head.appendChild(s);
})(document);
// delete the temporary CSS (for displaying all slides initially) when the user
// starts to view slides
(function() {
  var deleted = false;
  slideshow.on('beforeShowSlide', function(slide) {
    if (deleted) return;
    var sheets = document.styleSheets, node;
    for (var i = 0; i < sheets.length; i++) {
      node = sheets[i].ownerNode;
      if (node.dataset["target"] !== "print-only") continue;
      node.parentNode.removeChild(node);
    }
    deleted = true;
  });
})();
// add `data-at-shortcutkeys` attribute to <body> to resolve conflicts with JAWS
// screen reader (see PR #262)
(function(d) {
  let res = {};
  d.querySelectorAll('.remark-help-content table tr').forEach(tr => {
    const t = tr.querySelector('td:nth-child(2)').innerText;
    tr.querySelectorAll('td:first-child .key').forEach(key => {
      const k = key.innerText;
      if (/^[a-z]$/.test(k)) res[k] = t;  // must be a single letter (key)
    });
  });
  d.body.setAttribute('data-at-shortcutkeys', JSON.stringify(res));
})(document);
(function() {
  "use strict"
  // Replace <script> tags in slides area to make them executable
  var scripts = document.querySelectorAll(
    '.remark-slides-area .remark-slide-container script'
  );
  if (!scripts.length) return;
  for (var i = 0; i < scripts.length; i++) {
    var s = document.createElement('script');
    var code = document.createTextNode(scripts[i].textContent);
    s.appendChild(code);
    var scriptAttrs = scripts[i].attributes;
    for (var j = 0; j < scriptAttrs.length; j++) {
      s.setAttribute(scriptAttrs[j].name, scriptAttrs[j].value);
    }
    scripts[i].parentElement.replaceChild(s, scripts[i]);
  }
})();
(function() {
  var links = document.getElementsByTagName('a');
  for (var i = 0; i < links.length; i++) {
    if (/^(https?:)?\/\//.test(links[i].getAttribute('href'))) {
      links[i].target = '_blank';
    }
  }
})();
(function(time) {
  var d2 = function(number) {
    return ('0' + number).slice(-2); // left-pad 0 to minutes/seconds
  },

  time_format = function(total) {
    var secs = Math.abs(total) / 1000;
    var h = Math.floor(secs / 3600);
    var m = Math.floor(secs % 3600 / 60);
    var s = Math.round(secs % 60);
    var res = d2(m) + ':' + d2(s);
    if (h > 0) res = h + ':' + res;
    return res;  // [hh:]mm:ss
  },

  slide_number_div = function(i) {
    return document.getElementsByClassName('remark-slide-number').item(i);
  },

  current_page_number = function(i) {
    return slide_number_div(i).firstChild.textContent;  // text "i / N"
  };

  var timer = document.createElement('span'); timer.id = 'slide-time-left';
  var time_left = time, k = slideshow.getCurrentSlideIndex(),
      last_page_number = current_page_number(k);

  setInterval(function() {
    time_left = time_left - 1000;
    timer.innerHTML = ' ' + time_format(time_left);
    if (time_left < 0) timer.style.color = 'red';
  }, 1000);

  slide_number_div(k).appendChild(timer);

  slideshow.on('showSlide', function(slide) {
    var i = slide.getSlideIndex(), n = current_page_number(i);
    // reset timer when a new slide is shown and the page number is changed
    if (last_page_number !== n) {
      time_left = time; last_page_number = n;
      timer.innerHTML = ' ' + time_format(time); timer.style.color = null;
    }
    slide_number_div(i).appendChild(timer);
  });
})(60000);
// adds .remark-code-has-line-highlighted class to <pre> parent elements
// of code chunks containing highlighted lines with class .remark-code-line-highlighted
(function(d) {
  const hlines = d.querySelectorAll('.remark-code-line-highlighted');
  const preParents = [];
  const findPreParent = function(line, p = 0) {
    if (p > 1) return null; // traverse up no further than grandparent
    const el = line.parentElement;
    return el.tagName === "PRE" ? el : findPreParent(el, ++p);
  };

  for (let line of hlines) {
    let pre = findPreParent(line);
    if (pre && !preParents.includes(pre)) preParents.push(pre);
  }
  preParents.forEach(p => p.classList.add("remark-code-has-line-highlighted"));
})(document);</script>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <meta http-equiv="Content-Style-Type" content="text/css" />
  <meta name="generator" content="pandoc" />
  <title>timer.utf8</title>
  <style type="text/css">
      code{white-space: pre-wrap;}
      span.smallcaps{font-variant: small-caps;}
      span.underline{text-decoration: underline;}
      div.column{display: inline-block; vertical-align: top; width: 50%;}
  </style>
  <style type="text/css">.countdown {background: inherit;position: absolute;cursor: pointer;font-size: 100%;line-height: 1;border-color: #ddd;border-width: 3px;border-style: solid;border-radius: 15px;box-shadow: 0px 4px 10px 0px rgba(50, 50, 50, 0.4);-webkit-box-shadow: 0px 4px 10px 0px rgba(50, 50, 50, 0.4);margin: 0.6em;padding: 10px 15px;text-align: center;}.countdown {display: flex;align-items: center;justify-content: center;}.countdown .countdown-time {background: none;font-size: 100%;padding: 0;}.countdown-digits {color: inherit;}.countdown.running {border-color: #CECECE;background-color: #E5E5E5;}.countdown.running .countdown-digits {color: #393939;}.countdown.finished {border-color: #D83A20;background-color: #F04124;}.countdown.finished .countdown-digits {color: #3C1009;}.countdown.running.warning {border-color: #CFAE24;background-color: #E6C229;}.countdown.running.warning .countdown-digits {color: #39300A;}@-webkit-keyframes blink {from {opacity: 1}50% {opacity: 0.1}to {opacity: 1}}@keyframes blink {from {opacity: 1}50% {opacity: 0.1}to {opacity: 1}}.countdown.running.blink-colon .countdown-digits.colon {-webkit-animation: blink 2s steps(1, end) 0s infinite;animation: blink 2s steps(1, end) 0s infinite;}</style>
  <script>var counters = {timer: {}};
var update_timer = function(timer, force = false) {
	var secs = timer.value;

	// check if we should update timer or not
	noup = timer.div.className.match(/noupdate-\d+/);
	if (!force && noup != null) {
	  noup = parseInt(noup[0].match(/\d+$/));
	  if (secs > noup * 2 && secs % noup > 0) { return; }
	}

	// should we apply or remove warning class?
	warnwhen = timer.div.dataset.warnwhen;
	if (warnwhen && warnwhen > 0) {
	  if (secs <= warnwhen && !timer.div.classList.contains("warning")) {
	    timer.div.classList.add("warning");
	  } else if (secs > warnwhen && timer.div.classList.contains("warning")) {
	    timer.div.classList.remove("warning");
	  }
	}

  var mins = Math.floor(secs / 60); // 1 min = 60 secs
  secs -= mins * 60;

  // Update HTML
  timer.min.innerHTML = String(mins).padStart(2, 0);
  timer.sec.innerHTML = String(secs).padStart(2, 0);
}
var countdown = function (e) {
  target = e.target;
  if (target.classList.contains("countdown-digits")) {
    target = target.parentElement;
  }
  if (target.tagName == "CODE") {
    target = target.parentElement;
  }

  // Init counter
  if (!counters.timer.hasOwnProperty(target.id)) {
    counters.timer[target.id] = {};
    // Set the containers
	  counters.timer[target.id].min = target.getElementsByClassName("minutes")[0];
  	counters.timer[target.id].sec = target.getElementsByClassName("seconds")[0];
  	counters.timer[target.id].div = target;
  }

  if (!counters.timer[target.id].running) {
    if (!counters.timer[target.id].end) {
      counters.timer[target.id].end   = parseInt(counters.timer[target.id].min.innerHTML) * 60;
		  counters.timer[target.id].end  += parseInt(counters.timer[target.id].sec.innerHTML);
    }

    counters.timer[target.id].value = counters.timer[target.id].end;
    update_timer(counters.timer[target.id]);
    if (counters.ticker) counters.timer[target.id].value += 1;

    // Start if not past end date
    if (counters.timer[target.id].value > 0) {
      base_class = target.className.replace(/\s?(running|finished)/, "")
      target.className = base_class + " running";
      counters.timer[target.id].running = true;

      if (!counters.ticker) {
        counters.ticker = setInterval(counter_update_all, 1000);
      }
    }
  } else {
    // Bump timer value if running & clicked
    counters.timer[target.id].value += counter_bump_increment(counters.timer[target.id].end);
    update_timer(counters.timer[target.id], force = true);
    counters.timer[target.id].value += 1;
  }
};

var counter_bump_increment = function(val) {
  if (val <= 30) {
    return 5;
  } else if (val <= 300) {
    return 15;
  } else if (val <= 3000) {
    return 30;
  } else {
    return 60;
  }
}

var counter_update_all = function() {
  // Iterate over all running timers
  for (var i in counters.timer) {
    // Stop if passed end time
    console.log(counters.timer[i].id)
    counters.timer[i].value--;
    if (counters.timer[i].value <= 0) {
      counters.timer[i].min.innerHTML = "00";
      counters.timer[i].sec.innerHTML = "00";
      counters.timer[i].div.className = counters.timer[i].div.className.replace("running", "finished");
      counters.timer[i].running = false;
    } else {
      // Update
      update_timer(counters.timer[i]);

      // Play countdown sound if data-audio=true on container div
      let audio = counters.timer[i].div.dataset.audio
      if (audio && counters.timer[i].value == 5) {
        counter_play_sound(audio);
      }
    }
  }

  // If no more running timers, then clear ticker
  var timerIsRunning = false;
  for (var t in counters.timer) {
    timerIsRunning = timerIsRunning || counters.timer[t].running
  }
  if (!timerIsRunning) {
    clearInterval(counters.ticker);
    counters.ticker = null;
  }
}

var counter_play_sound = function(url) {
  if (typeof url === 'boolean') {
    url = 'libs/countdown/smb_stage_clear.mp3';
  }
  sound = new Audio(url);
  sound.play();
}

var counter_addEventListener = function() {
  if (!document.getElementsByClassName("countdown").length) {
    setTimeout(counter_addEventListener, 2);
    return;
  }
  var counter_divs = document.getElementsByClassName("countdown");
  console.log(counter_divs);
  for (var i = 0; i < counter_divs.length; i++) {
    counter_divs[i].addEventListener("click", countdown, false);
  }
};

counter_addEventListener();
</script>
</head>
<body>
<div class="countdown blink-colon noupdate-5" id="timer_5fafc5fe" style="top:1.5%;right:0;font-size:100%;z-index:100" data-warnwhen="300">
<code class="countdown-time"><span class="countdown-digits minutes">30</span><span class="countdown-digits colon">:</span><span class="countdown-digits seconds">00</span></code>
</div>
</body>
</html>

<script>
slideshow._releaseMath = function(el) {
  var i, text, code, codes = el.getElementsByTagName('code');
  for (i = 0; i < codes.length;) {
    code = codes[i];
    if (code.parentNode.tagName !== 'PRE' && code.childElementCount === 0) {
      text = code.textContent;
      if (/^\\\((.|\s)+\\\)$/.test(text) || /^\\\[(.|\s)+\\\]$/.test(text) ||
          /^\$\$(.|\s)+\$\$$/.test(text) ||
          /^\\begin\{([^}]+)\}(.|\s)+\\end\{[^}]+\}$/.test(text)) {
        code.outerHTML = code.innerHTML;  // remove <code></code>
        continue;
      }
    }
    i++;
  }
};
slideshow._releaseMath(document);
</script>
<!-- dynamically load mathjax for compatibility with self-contained -->
<script>
(function () {
  var script = document.createElement('script');
  script.type = 'text/javascript';
  script.src  = 'https://mathjax.rstudio.com/latest/MathJax.js?config=TeX-MML-AM_CHTML';
  if (location.protocol !== 'file:' && /^https?:/.test(script.src))
    script.src  = script.src.replace(/^https?:/, '');
  document.getElementsByTagName('head')[0].appendChild(script);
})();
</script>
  </body>
</html>
